解决库存超卖解决方案
1.JVM本地锁
    QPS:320
    以下三种情况会导致锁失效
     1.多例模式
     2.事务影响
     3.集群部署
2.使用一条sql实现更新时在查询库存量（update stock set count=count-1 where id = #{id} and count>=1）
    QPS:3000
    问题：
        1.锁范围失效
        2.当同一个产品有多条库存记录时
        2.无法记录更新库存前后数据状态
3.悲观锁（select ... for update）要手动事务
    QPS：1600
    问题：
        1.性能问题
        2.死锁问题：对多条数据加锁时要顺序一致
        3.库存操作要统一
4.乐观锁（数据库添加version字段 CAS机制）
    QPS：300
    问题：
        1.高并发情况下，性能极低
        2.ABA问题
        3.读写分离机制下，导致乐观锁不可靠

 总结：
 性能：一个SQL > 悲观锁 > JVM锁 > 乐观锁
 追求极致性能：一个SQL
 并发量低：乐观锁
 并发量高：悲观锁
 不推荐：JVM锁

 ##################################

 Redis分布式锁
 1.基于Redis实现
    特征：
        1.独占排他
        2.防死锁发生，如果redis客户端从redis服务中获取锁后立刻宕机(锁设置过期时间)
        3.原子性（设置锁和过期时间保证原子性 set kv ex 3 nx，判断和释放锁之间保持原子性lua）
        4.防误删（UUID），使用Lua脚本实现锁的判断和删除原子性
        5.自动续期（Timer定时器+lua）
        6.可重入性（hash+lua）
     redisson：redis的java客户端（分布式锁） 依赖lua脚本的原子性，实现加锁和释放锁的功能
        可重入锁：getLock() RLock对象 lock.lock()/unlock()
        公平锁：getFairLock()
        联锁和红锁
        读写锁
 2.基于Zookeeper实现
 3.基于MySQL实现